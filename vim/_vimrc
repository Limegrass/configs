" ==============================================================================
" Author: James Ni (Limegrass) - @Multipoke
" Sections:
"   VIM_PLUG:
"   PLUGIN_SETTINGS:
"   PLUGIN_MAPS:
"   FUNCTION_DEFINITIONS:
"   VARIABLE_DEFINITIONS:
"   AUTOCOMMANDS:
"   BASIC_SETTINGS:
"   MAPS_AND_ABBREVS:
"     ALL_MODES
"     NORMAL_MODE
"     VISUAL_MODE
"     INSERT_MODE
"     COMMANDS
"     ABBREVIATIONS
" Jump with # or *
" ==============================================================================

" INITIALIZATION
cd $HOME

let $LOCALRC = $HOME . '/local.vim'
if filereadable($LOCALRC)
    source $LOCALRC
endif

set encoding=utf-8
scriptencoding utf-8

let GVIM_WIDTH = 999
let GVIM_HEIGHT = 999

let $GITDIR = $HOME.'\git'
if !isdirectory($GITDIR)
    silent call mkdir($GITDIR)
endif

let $GARBAGEDIR = $GITDIR.'\garbage'
if !isdirectory($GARBAGEDIR)
    silent call mkdir($GARBAGEDIR)
endif

let $GITVIMDIR = $GITDIR.'\configs\vim\'
let $VIMRC     = $GITVIMDIR.'\_vimrc'
let $VSVIMRC   = $GITVIMDIR.'\_vsvimrc'
let $IDEAVIMRC = $GITVIMDIR.'\_ideavimrc'

if has('win32') || has('win32unix')
    let $VIMDIR = $HOME.'\vimfiles'
else
    let $VIMDIR = $HOME.'\.vim'
endif

let mapleader="\<SPACE>"
nnoremap <SPACE> <NOP>

" ==============================================================================
" VIM_PLUG
" ==============================================================================

if empty(glob($VIMDIR.'/autoload/plug.vim'))
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
        \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif
call plug#begin($VIMDIR.'/plugged')

" Editing/Core
Plug 'tpope/vim-surround'
Plug 'tpope/vim-dadbod'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-abolish'
Plug 'sjl/gundo.vim', {'on': 'GundoToggle'}
Plug 'mg979/vim-visual-multi'
Plug 'tpope/vim-obsession'
Plug 'wellle/targets.vim'
Plug 'michaeljsmith/vim-indent-object'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-scriptease'
Plug 'haya14busa/incsearch.vim'
    Plug 'haya14busa/incsearch-fuzzy.vim'
Plug 'SirVer/ultisnips'
Plug 'honza/vim-snippets'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
    Plug 'junegunn/fzf.vim'
Plug 'majutsushi/tagbar', { 'on': 'TagbarToggle' }
Plug 'previm/previm', {'for': ['markdown']}
    Plug 'tyru/open-browser.vim'
Plug 'tpope/vim-dispatch'
Plug 'sheerun/vim-polyglot'
" Appearances
Plug 'flazz/vim-colorschemes'
Plug 'bling/vim-airline'
Plug 'nathanaelkane/vim-indent-guides'
Plug 'vim-airline/vim-airline-themes'
Plug 'gcmt/taboo.vim'
Plug 'godlygeek/tabular'
" Plug 'rickhowe/diffchar.vim'

Plug 'Shougo/neco-vim'
Plug 'neoclide/coc-neco'
Plug 'neoclide/coc.nvim', {'tag': '*', 'do': { -> coc#util#install()}}
" if !nvim !yarn global add vim-node-rpc

" Syntax
Plug 'PProvost/vim-ps1'
Plug 'OrangeT/vim-csharp', {'for': ['cs']}
Plug 'lervag/vimtex', {'for': ['tex']}
Plug 'cakebaker/scss-syntax.vim', {'for': ['cs', 'html', 'cshtml', 'scss', 'css']}
Plug 'mhartington/nvim-typescript', {'for': ['ts']}
Plug 'aonemd/kuroi.vim'
call plug#end()

source $GITVIMDIR\cocrc.vim

" ==============================================================================
" PLUGIN_SETTINGS
" ==============================================================================

let g:indent_guides_enable_on_vim_startup = 1

let g:taboo_tab_format=' %N [%f%m] '

let g:airline_theme='deus'

let g:gundo_prefer_python3 = 1

" ncm-clang
let g:clang_make_default_keymappings = 0
let g:clang_auto_user_options = ''

" vimtex
let g:vimtex_view_general_viewer  = 'SumatraPDF'
let g:vimtex_view_general_options =
            \'-reuse-instance -forward-search @tex @line @pdf'
let g:vimtex_view_general_options_latexmk = '-reuse-instance'

" Previm
let g:previm_enable_realtime = 0

" ==============================================================================
" PLUGIN_MAPS
" ==============================================================================
" Vim-commentary bind
nnoremap <leader><Tab> :Commentary<CR>
xnoremap <leader><Tab> :Commentary<CR>

" FZF
nnoremap <C-SPACE>   :Buffers<CR>
nnoremap <C-S-SPACE> :FZF<CR>

" Gundo
nnoremap <leader>u :GundoToggle<CR>

" tagbar
nnoremap <F2> :TagbarToggle<CR>

" incsearch/fuzzy rebindings
let g:incsearch#auto_nohlsearch = 1
nmap n  <Plug>(incsearch-nohl-n)
nmap N  <Plug>(incsearch-nohl-N)
nmap *  <Plug>(incsearch-nohl-*)
nmap #  <Plug>(incsearch-nohl-#)
nmap g* <Plug>(incsearch-nohl-g*)
nmap g# <Plug>(incsearch-nohl-g#)
nmap /  <Plug>(incsearch-forward)
nmap ?  <Plug>(incsearch-backward)
nmap g/ <Plug>(incsearch-stay)
nmap <leader>/ <Plug>(incsearch-fuzzyspell-/)
nmap <leader>? <Plug>(incsearch-fuzzyspell-?)
nmap <leader>g/ <Plug>(incsearch-fuzzyspell-stay)

" Ultisnips with ncm
let g:UltiSnipsExpandTrigger       = "<Plug>(ultisnips_expand)"
let g:UltiSnipsJumpForwardTrigger  = "<nop>"
let g:UltiSnipsJumpBackwardTrigger = "<nop>"
let g:UltiSnipsRemoveSelectModeMappings = 0

" TODO: Find a way to not show pum when the one entry = the entered text
inoremap <silent> <TAB> <C-R>=ForwardJumpOrTab()<CR>
snoremap <TAB> <C-O>:call UltiSnips#JumpForwards()<CR>
function! ForwardJumpOrTab()
    let g:ulti_jump_forwards_res = 0
    call UltiSnips#JumpForwards()
    if g:ulti_jump_forwards_res
        return ""
    elseif pumvisible()
        return coc#_select_confirm()
    endif
    return "\<TAB>"
endfunction


inoremap <silent> <S-TAB> <C-R>=BackwardJumpOrSTab()<CR>
snoremap <silent> <S-TAB> <C-O>:call UltiSnips#JumpBackwards()<CR>
function! BackwardJumpOrSTab()
    let g:ulti_jump_backwards_res = 0
    call UltiSnips#JumpBackwards()
    if g:ulti_jump_backwards_res
        return ""
    endif
    return "\<C-O><<"
endfunction

" ==============================================================================
" FUNCTION_DEFINITIONS
" ==============================================================================

set diffexpr=MyDiff()
function! MyDiff()
    let opt = '-a --binary '
    if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
    if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
    let arg1 = v:fname_in
    if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
    let arg2 = v:fname_new
    if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
    let arg3 = v:fname_out
    if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
    if $VIMRUNTIME =~ ' '
        if &sh =~ '\<cmd'
            if empty(&shellxquote)
                let l:shxq_sav = ''
                set shellxquote&
            endif
            let cmd = '"' . $VIMRUNTIME . '\diff"'
        else
            let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
        endif
    else
        let cmd = $VIMRUNTIME . '\diff'
    endif
    silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3
    if exists('l:shxq_sav')
        let &shellxquote=l:shxq_sav
    endif
endfunction

" Abbrev in command mode if not system cmd
function! CommandAbbreviations(abbrebiation, command)
    let l:abbrev = '''' . a:abbrebiation . ''''
    let l:command = '''' . a:command . ''''
    let l:exec = ' cnoreabbrev <expr> '.a:abbrebiation.
                \' (getcmdtype() is# '':'''.' && getcmdline() is# '.l:abbrev.')'.
                \'?('.l:command.')'.':('.l:abbrev.')'
    execute l:exec
endfunction

" Normalizes a document with both tabs and spaces
function! Retab(...) range
    if (a:0 < 2)
        execute a:firstline.','.a:lastline.' retab'
        return
    endif

    set expandtab
    let &tabstop=a:1
    let &softtabstop=a:1
    let &shiftwidth=a:1
    set noexpandtab
    if (a:firstline == a:lastline)
        retab!
    else
        execute a:firstline.','.a:lastline.' retab!'
    endif
    let &tabstop=a:2
    let &softtabstop=a:2
    let &shiftwidth=a:2
    set expandtab
    if (a:firstline == a:lastline)
        retab!
    else
        execute a:firstline.','.a:lastline.' retab'
    endif
endfunction

" Execute command while preserving cursor location
function! Preserve(command)
    " save last search, and cursor position.
    let _s=@/
    let l = line(".")
    let c = col(".")
    execute a:command
    " Clean up: restore previous search history, and cursor position
    let @/=_s
    call cursor(l, c)
endfunction

function! ToggleBool(setting)
    if !exists(a:setting)
        silent execute 'let '.a:setting.' = 0'
    endif
    execute 'let '.a:setting.' = !'.a:setting
    let l:reg = @b
    redir @b
    silent execute 'echo '.a:setting
    redir END
    echo a:setting.' = '.trim(@b)
    let @b = l:reg
endfunction

function! Registers()
    register
    call inputsave()
    let l:register = input('Register: ')
    call inputrestore()
    return getreg(l:register)
endfunction

function! DBProfile(profile)
      execute 'DBSetOption profile=' . a:profile
      setf sql
      DBCompleteTables
endfunction

function! StartBrowser(link)
    if has('win32')
        silent execute '!start '.a:link
    else
        silent execute '!xdg-open'.a:link
    endif
endfunction

function! ClearRegisters(chars)
    let l:regs = split(a:chars, '\zs')
    for r in l:regs
        call setreg(r, [])
    endfor
endfunction

function! CopyRegisterFromInto(from, into)
    execute "call setreg('".a:into."', getreg('".a:from."'))"
endfunction

function! GetVisualSelection()
    let [line_start, column_start] = getpos("'<")[1:2]
    let [line_end, column_end] = getpos("'>")[1:2]
    let lines = getline(line_start, line_end)
    if len(lines) == 0
        return ''
    endif
    let lines[-1] = lines[-1][: column_end - (&selection == 'inclusive' ? 1 : 2)]
    let lines[0] = lines[0][column_start - 1:]
    return join(lines, "\n")
endfunction


function! RepeatForList(commandPrefix, commandSuffix, argsList)
    for l:argument in a:argsList
        execute a:commandPrefix . l:argument . a:commandSuffix
    endfor
endfunction

" Like gJ, but always remove spaces
function! JoinSpaceless()
    execute 'normal gJ'
    " Character under cursor is whitespace?
    if matchstr(getline('.'), '\%' . col('.') . 'c.') =~ '\s'
        " When remove it!
        execute 'normal dw'
    endif
endfunction

" ==============================================================================
" AUTOCOMMANDS
" ==============================================================================
" QuickFix window on vimgrep
if has('autocmd')
    augroup QuickFix
        autocmd!
        " autocmd QuickFixCmdPost [^l]* cwindow
        " autocmd QuickFixCmdPost l*        lwindow
        autocmd CmdwinEnter * nnoremap <CR> <CR>
        autocmd BufReadPost quickfix nnoremap <buffer> <CR> <CR>
    augroup END

    " Set spellchecking on for text buffers
    augroup Spell
        autocmd!
        autocmd Filetype text setlocal spell
        autocmd Filetype help setlocal nospell
    augroup END

    " Autocompletion for HTML tags
    augroup Html
        autocmd!
        autocmd Filetype html,xml,markdown inoremap <buffer> </ </<C-X><C-O>
    augroup END

    augroup PrevimSettings
        autocmd!
        autocmd BufNewFile,BufRead *.{md,mdwn,mkd,mkdn,mark*} set filetype=markdown
    augroup END
endif

" ==============================================================================
" BASIC_SETTINGS
" ==============================================================================
set ruler
set incsearch
set ignorecase
set smartcase
set number
set wrap
set wildmenu
set guioptions=c
set listchars=tab:▸\ ,trail:·,precedes:←,extends:→,nbsp:·
set backspace=indent,eol,start
set scrolljump=3
set list
set selection=inclusive
set undofile
set history=100
set lazyredraw
set cursorline
set hidden
set diffopt+=vertical,iwhite
set fileformat=unix
set virtualedit=all
set nostartofline
set spelllang=en
set mouse=nicr
set splitright
set splitbelow
set foldmethod=indent
set foldlevel=99
set sessionoptions+=tabpages,globals
set completeopt=noinsert,menuone,noselect
runtime macros/matchit.vim
" INDENT SETTINGS
set expandtab
set smartindent
set autoindent
set tabstop=4
set shiftwidth=4
set softtabstop=-1
" Character limit highlight
call matchadd('ColorColumn', '\%81v.', 100)
" Prevent starting in Hiragana
set iminsert=0
set imsearch=-1

" set clipboard=unnamed " system register

" Put undo/swap/temp files user's vim subfolder
let $UNDODIR=$VIMDIR.'/undo'
if !isdirectory($UNDODIR)
    silent call mkdir($UNDODIR)
endif
set undodir=$UNDODIR

let $BACKUPDIR=$VIMDIR.'/backup'
if !isdirectory($BACKUPDIR)
    silent call mkdir($BACKUPDIR)
endif
set backupdir=$BACKUPDIR

let $SWAPDIR=$VIMDIR.'/swap'
if !isdirectory($SWAPDIR)
    silent call mkdir($SWAPDIR)
endif
set directory=$SWAPDIR

set termguicolors
set background=dark
colorscheme kuroi " corporation, hybrid, zenburn
set guifont=Consolas:h9
if has('gui_running')
    let &lines=GVIM_HEIGHT
    let &columns=GVIM_WIDTH
endif

" ==============================================================================
" VARIABLE_DEFINITIONS
" ==============================================================================
let g:guid_regex = '[a-zA-Z0-9]\{8,8}-[a-zA-Z0-9]\{4,4}-'
            \ .'[a-zA-Z0-9]\{4,4}-[a-zA-Z0-9]\{4,4}-[a-zA-Z0-9]\{12,12}'

" ==============================================================================
" MAPS_AND_ABBREVS
" ==============================================================================
" ================================ ALL_MODES ===================================
" Remap J, K some to navigate visible lines
nnoremap j gj
nnoremap gj j
nnoremap k gk
nnoremap gk k
nnoremap $ g$
nnoremap g$ $
nnoremap 0 g0
nnoremap g0 0
xnoremap <expr> j  mode() ==# "v" ? "gj" : "j"
xnoremap <expr> gj mode() ==# "v" ? "j"  : "gj"
xnoremap <expr> k  mode() ==# "v" ? "gk" : "k"
xnoremap <expr> gk mode() ==# "v" ? "k"  : "gk"
inoremap <expr> <UP>   pumvisible() ? "\<C-P>" : "\<C-O>gk"
inoremap <expr> <DOWN> pumvisible() ? "\<C-N>" : "\<C-O>gj"


" ALT+jk to move lines up and down
nnoremap <A-j>      :move .+1<CR>==
nnoremap <A-k>      :move .-2<CR>==
xnoremap <A-j>      :move '>+1<CR>gv=gv
xnoremap <A-k>      :move '<-2<CR>gv=gv
inoremap <A-j> <Esc>:move .+1<CR>==gi
inoremap <A-k> <Esc>:move .-2<CR>==gi

" =============================== NORMAL_MODE ==================================
nnoremap <leader>v :execute 'edit $VIMRC \| setlocal fileformat=unix'<CR>
nnoremap <leader>V :execute 'tabnew $VIMRC \| setlocal fileformat=unix'<CR>
nnoremap <leader>S :source $MYVIMRC<CR>
" HELP Right split
nnoremap K K<C-W>L
nnoremap Q @q
nnoremap <C-W>v :vnew<CR>
nnoremap <C-W>s :new<CR>

nnoremap Y y$
nnoremap <leader>= "+
nnoremap <leader>p "+p
nnoremap <leader>P "+P
nnoremap <leader>y "+y
nnoremap yc "+y

nnoremap + "+
" Maps yr to copy registers
function! MapYankRegister()
    let l:regs = split('abcdefghijklmnopqrstuvwxyz1234567890"-:.%#=*+~/', '\zs')
    for l:from in l:regs
        for l:into in l:regs
            execute 'nnoremap yr'. l:from . l:into . ' :CopyRegisterFromInto '
                        \. l:from . ' ' . l:into . '<CR>'
        endfor
    endfor
endfunction
call MapYankRegister()

" Search for word currently under cursor
nnoremap // yiw/<C-R>"

nnoremap cm :silent call SplitCommas()<CR>
function! SplitCommas()
    s/,\s*/,\r/g
    retab
endfunction

nnoremap >( :silent call AlignToCharInPreviousLine('(')<CR>
nnoremap >" :silent call AlignToCharInPreviousLine('"')<CR>
nnoremap >' :silent call AlignToCharInPreviousLine("'")<CR>
" Aligns beginning of current line to char of previous line
function! AlignToCharInPreviousLine(char)
    let l:prefix = 'normal ^kyf'
    let l:suffix = 'jPv0r '
    exec l:prefix.a:char.l:suffix
endfunction

"TODO: Create a better mapping (and function itself) for splitting (cm) and
" aligning

" Reciprocal of {count}gT
nnoremap <leader>gt :<C-U>execute 'normal '.repeat("gt", v:count1)<CR>
" Change working directory to current file
nnoremap <leader>cd :cd %:p:h<CR>
" Open file explorer on current file location
if has('win32')
    nnoremap <leader>e :silent !explorer.exe %:p:h<CR>
endif
" Copy file path to system register
nnoremap <leader>fp :let @+=expand("%:p")<CR>
" Navigate out of terminal mode
if has('nvim')
    tnoremap <ESC> <C-\><C-N>
endif
" Remap tag jump to Shift+Ctrl+T, Map Ctrl+T to new tab
nnoremap <S-C-T> <C-T>
nnoremap <C-T> :tabedit<CR>
" Mark TODO as DONE
nnoremap <leader>z :s/TODO/DONE/<CR>
nnoremap <leader>T :vimgrep /TODO/ %<CR>

nnoremap <F4> :execute 'bd \| bn'<CR>
nnoremap <leader><F4> windo bd<CR>

nnoremap <Leader>J :call JoinSpaceless()<CR>

" =============================== VISUAL_MODE ==================================
" Retain selection when indenting in visual mode
xnoremap > >gv
xnoremap < <gv
xnoremap <Tab> >gv
xnoremap <S-Tab> <gv
xnoremap <leader>= "+
xnoremap <leader>p "+p
xnoremap <leader>P "+P
xnoremap <leader>y "+y
xnoremap . :normal .<CR>

" Search for visual selected
xnoremap // y/<C-R>"<CR>

" =============================== INSERT_MODE ==================================
" CTRL+BS/DEL like other editors
inoremap <C-BS> <C-W>
inoremap <C-DEL> <C-O>dw
inoremap <C-V> <C-O>p
inoremap <C-S-V> <C-V>
" Close popup menu with <S-Space>
" inoremap <expr> <S-SPACE>  pumvisible() ? "\<C-E>" : "\<S-SPACE>"
" Paste from system register with <C-R>r
inoremap <C-R><C-R> <C-R>+
inoremap <C-R><C-E> <C-R>0

" =============================== COMMANDS =====================================
cnoremap <C-BS> <C-W>

" Paste from system register with <C-R>r
cnoremap <C-R><C-R> <C-R>+

" Function shortcuts
command! -nargs=* -range Retab <line1>,<line2>call Retab(<f-args>)
command! -nargs=0 StripTrailingWhiteSpace call Preserve('%s/\s\+$//e') | call Preserve('%s/\($\n\s*\)\+\%$//e')
command! -nargs=0 Reindent call Preserve('normal gg=G')
command! -nargs=0 Clipboard call Preserve('normal gg"+yG')
command! -nargs=1 ClearRegister call ClearRegister(<q-args>)
command! -nargs=+ CopyRegisterFromInto call CopyRegisterFromInto(<f-args>)
command! -nargs=1 Google call StartBrowser('https://google.com/search?q='.<q-args>)

command! -nargs=* -range Jisho call Jisho(<f-args>)
function! Jisho(...) range
    if a:0 > 0
        let l:argsList = a:000
    else
        let l:argsList = split(GetVisualSelection())
    endif
    call RepeatForList("call ".
        \ "StartBrowser('https://jisho.org/search/", "')",
        \ l:argsList)
endfunction


command! -nargs=1 SplitLines call SplitLines(<f-args>)
function! SplitLines(delimiter)
    let l:cmd = 's/'.a:delimiter.'/\r/g'
    execute l:cmd
endfunction

command! -nargs=1 Sudo call Sudo(<q-args>)
function! Sudo(cmd)
    if has('win32')
        " TODO: Fix this for passwordless accounts
        execute 'silent !runas /user:\%USERNAME\%@\%USERDOMAIN\% "' . a:cmd . '"'
    else
        execute 'silent !sudo ' . a:cmd
    endif
endfunction

" Dealing with my typos
command! W w
command! -bang W w
command! Q q
command! -bang Q q

command! TogglePrevimLive call ToggleBool('g:previm_enable_realtime')

" Sudo write in UNIX
if !has('win32')
    command! -nargs=0 Sw w silent !sudo tee % > /dev/null
endif

" =============================== ABBREVIATIONS ================================
" Force vertical splits for help files and expand gui window for help
call CommandAbbreviations('h', 'vert help')
call CommandAbbreviations('help', 'vert help')
call CommandAbbreviations('hh', 'help')
call CommandAbbreviations('hhelp', 'help')
call CommandAbbreviations('doff', 'diffoff')
call CommandAbbreviations('dt', 'diffthis')
call CommandAbbreviations('vb', 'vert sb')
call CommandAbbreviations('H', 'helpgrep')
call CommandAbbreviations('bdall', '%bd\|e#')

cd $GARBAGEDIR

" TODO
" LSP
" inoremap <C-SPACE> to force open ncm2 pum
" Fix this function
" inoremap <C-R> <C-O>:set nopaste
" function! NoAutoIndentPaste(command)
"       set nopaste
"       <C-R>command
"       set paste
" endfunction
"
" Things to check back on
" Plug 'Floobits/floobits-vim'
" Plug 'FredKSchott/CoVim'
" Plug 'ncm2/ncm2-tmux'
" Plug 'filipekiss/ncm2-look.vim'
"
" Automatically set register v to whatever was visually selected last on
" entering visual mode
" Ideavimrc mappings (:actionlist)
" Autocurl, extract and helptext dbext
" Split into multiple files?

